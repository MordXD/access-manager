# tests/conftest.py
import asyncio
import os
from uuid import uuid4

import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker, selectinload, select

from src.access_manager.main import app
from src.access_manager.db import get_db, Base
from src.access_manager.models import User, Role, Permission
from src.access_manager.security import get_password_hash, create_access_token

TEST_DB_URL = os.getenv(
    "TEST_DATABASE_URL",
    "sqlite+aiosqlite:///./test_db.sqlite",
)

# AnyIO нужен для @pytest.mark.anyio
@pytest.fixture(scope="session")
def anyio_backend():
    return "asyncio"


@pytest.fixture(scope="session")
def event_loop():
    """
    Отдельный event-loop на всю сессию тестов.
    """
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


# ──────────────────────────────────────────────────────────────────────────
#  Async-движок и фабрика сессий
# ──────────────────────────────────────────────────────────────────────────
@pytest.fixture(scope="session")
async def engine():
    engine = create_async_engine(TEST_DB_URL, future=True, echo=False)

    async with engine.begin() as conn:
        # Полностью перестраиваем схему на чистую
        await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all)

    yield engine
    await engine.dispose()


@pytest.fixture(scope="session")
def session_maker(engine):
    return sessionmaker(bind=engine, class_=AsyncSession, expire_on_commit=False)


@pytest.fixture(scope="function")
async def db(session_maker):
    """
    «Сырая» сессия БД для прямой работы в тестах.
    Откатываем всё, что не нужно, в конце теста.
    """
    async with session_maker() as session:
        yield session
        # По-хорошему rollback’а хватает, но держим commit для явности
        await session.rollback()


# ──────────────────────────────────────────────────────────────────────────
#  Подмена зависимости get_db → тестовая сессия
# ──────────────────────────────────────────────────────────────────────────
@pytest.fixture(scope="function")
async def client(session_maker):
    async def _get_test_db():
        async with session_maker() as session:
            yield session

    app.dependency_overrides[get_db] = _get_test_db

    async with AsyncClient(app=app, base_url="http://testserver") as ac:
        yield ac

    app.dependency_overrides.clear()


# ──────────────────────────────────────────────────────────────────────────
#  Суперпользователь + Bearer-токен
# ──────────────────────────────────────────────────────────────────────────
async def _ensure_permission(session: AsyncSession, name: str) -> Permission:
    stmt = select(Permission).where(Permission.name == name)
    result = await session.execute(stmt)
    perm = result.scalar_one_or_none()
    if perm:
        return perm
    perm = Permission(name=name, description=f"{name} autogenerated for tests")
    session.add(perm)
    await session.flush()
    return perm


@pytest.fixture(scope="function")
async def auth_header(session_maker):
    """
    Заголовок { 'Authorization': 'Bearer …' } для запросов к защищённым эндпойнтам.
    Создаёт:
      • обязательные permissions (`create_user`, `read_user`, …)
      • роль `admin` с этими разрешениями
      • суперпользователя admin / password
    """
    async with session_maker() as session:
        required_perms = [
            "create_user",
            "read_user",
            "update_user",
            "delete_user",
            "create_role",
            "read_role",
            "update_role",
            "delete_role",
            "create_permission",
            "read_permission",
            "update_permission",
            "delete_permission",
        ]
        perms = [await _ensure_permission(session, name) for name in required_perms]

        # Роль «admin» (idempotent)
        stmt = select(Role).where(Role.name == "admin").options(selectinload(Role.permissions))
        result = await session.execute(stmt)
        role = result.scalar_one_or_none()
        if not role:
            role = Role(name="admin", description="Autogenerated admin role")
            session.add(role)
            await session.flush()
        # Обновляем список perm’ов у роли, если он был не полный
        role.permissions = perms

        # Суперпользователь
        stmt = select(User).where(User.username == "admin")
        result = await session.execute(stmt)
        user = result.scalar_one_or_none()
        if not user:
            user = User(
                username="admin",
                email="admin@example.com",
                hashed_password=get_password_hash("password"),
                is_active=True,
                is_superuser=True,
            )
            session.add(user)
            await session.flush()
        # Убеждаемся, что роль прикреплена
        if role not in user.roles:
            user.roles.append(role)

        await session.commit()

        token = create_access_token({"sub": str(user.id)})
        return {"Authorization": f"Bearer {token}"}
